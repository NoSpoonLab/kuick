package kuick.client.redis

import io.lettuce.core.*
import io.lettuce.core.api.*
import io.lettuce.core.api.async.*
import io.lettuce.core.codec.*
import io.lettuce.core.pubsub.*
import io.lettuce.core.pubsub.api.async.*
import java.util.concurrent.*
import kotlin.coroutines.*

// Try redis locally:
// - docker run redis
// - docker exec -it `docker ps -l --format "{{.ID}}"` redis-cli

suspend fun <K, V> RedisClient.connectSuspend(uri: RedisURI, codec: RedisCodec<K, V>) = this.connectAsync(codec, uri).await()
suspend fun <K, V> RedisClient.connectPubSubSuspend(uri: RedisURI, codec: RedisCodec<K, V>) = this.connectPubSubAsync(codec, uri).await()

suspend fun RedisClient.connectSuspend(uri: RedisURI) = connectSuspend(uri, StringCodec())
suspend fun RedisClient.connectPubSubSuspend(uri: RedisURI): StatefulRedisPubSubConnection<String, String> = connectPubSubSuspend(uri, StringCodec())

suspend fun <K, V> StatefulConnection<K, V>.closeSuspend() = closeAsync().await()

fun <K, V> StatefulRedisPubSubConnection<K, V>.suspending() = RedisPubSubSuspendCommands(async())
fun <K, V> StatefulRedisConnection<K, V>.suspending(): RedisSuspendCommands<K, V> = RedisSuspendCommands(this.async())

@Suppress("RedundantSuspendModifier", "unused")
class RedisPubSubSuspendCommands<K, V>(val asyncPubsub: RedisPubSubAsyncCommands<K, V>) : RedisSuspendCommands<K, V>(asyncPubsub) {

    /**
     * Listen for messages published to channels matching the given patterns.
     *
     * @param patterns the patterns
     * @return RedisFuture&lt;Void&gt; Future to synchronize {@code psubscribe} completion
     */
    suspend fun psubscribe(vararg patterns: K) = asyncPubsub.psubscribe(*patterns).await(0L, TimeUnit.SECONDS)

    /**
     * Stop listening for messages posted to channels matching the given patterns.
     *
     * @param patterns the patterns
     * @return RedisFuture&lt;Void&gt; Future to synchronize {@code punsubscribe} completion
     */
    suspend fun punsubscribe(vararg patterns: K) = asyncPubsub.punsubscribe(*patterns).await()

    /**
     * Listen for messages published to the given channels.
     *
     * @param channels the channels
     * @return RedisFuture&lt;Void&gt; Future to synchronize {@code subscribe} completion
     */
    suspend fun subscribe(vararg channels: K) = asyncPubsub.subscribe(*channels).await()

    /**
     * Stop listening for messages posted to the given channels.
     *
     * @param channels the channels
     * @return RedisFuture&lt;Void&gt; Future to synchronize {@code unsubscribe} completion.
     */
    suspend fun unsubscribe(vararg channels: K) = asyncPubsub.unsubscribe(*channels).await()
}

@Suppress("unused", "HasPlatformType", "HasPlatformType", "SpellCheckingInspection", "DEPRECATION", "RedundantSuspendModifier")
open class RedisSuspendCommands<K, V>(val async: RedisAsyncCommands<K, V>) {
    /*
    suspend fun set(key: K, value: V) = async.set(key, value).await()
    suspend fun get(key: K) = async.get(key).await()
    suspend fun exists(key: K) = async.exists(key).await()
    suspend fun del(key: K) = async.del(key).await()
    suspend fun hset(key: K, field: K, value: V) = async.hset(key, field, value).await()
    suspend fun hget(key: K, field: K) = async.hget(key, field).await()
    suspend fun hexists(key: K, field: K) = async.hexists(key, field).await()
    suspend fun hdel(key: K, field: K) = async.hdel(key, field).await()
    */

    suspend fun append(arg0: K, arg1: V) = async.append(arg0, arg1).await()
    suspend fun asking() = async.asking().await()
    suspend fun auth(arg0: kotlin.String) = async.auth(arg0)
    suspend fun bgrewriteaof() = async.bgrewriteaof().await()
    suspend fun bgsave() = async.bgsave().await()
    suspend fun bitcount(arg0: K) = async.bitcount(arg0).await()
    suspend fun bitcount(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.bitcount(arg0, arg1, arg2).await()
    suspend fun bitfield(arg0: K, arg1: io.lettuce.core.BitFieldArgs) = async.bitfield(arg0, arg1).await()
    suspend fun bitopAnd(arg0: K, vararg arg1: K) = async.bitopAnd(arg0, *arg1).await()
    suspend fun bitopNot(arg0: K, arg1: K) = async.bitopNot(arg0, arg1).await()
    suspend fun bitopOr(arg0: K, vararg arg1: K) = async.bitopOr(arg0, *arg1).await()
    suspend fun bitopXor(arg0: K, vararg arg1: K) = async.bitopXor(arg0, *arg1).await()
    suspend fun bitpos(arg0: K, arg1: kotlin.Boolean, arg2: kotlin.Long) = async.bitpos(arg0, arg1, arg2).await()
    suspend fun bitpos(arg0: K, arg1: kotlin.Boolean) = async.bitpos(arg0, arg1).await()
    suspend fun bitpos(arg0: K, arg1: kotlin.Boolean, arg2: kotlin.Long, arg3: kotlin.Long) = async.bitpos(arg0, arg1, arg2, arg3).await()
    suspend fun blpop(arg0: kotlin.Long, vararg arg1: K) = async.blpop(arg0, *arg1).await()
    suspend fun brpop(arg0: kotlin.Long, vararg arg1: K) = async.brpop(arg0, *arg1).await()
    suspend fun brpoplpush(arg0: kotlin.Long, arg1: K, arg2: K) = async.brpoplpush(arg0, arg1, arg2).await()
    suspend fun bzpopmax(arg0: kotlin.Long, vararg arg1: K) = async.bzpopmax(arg0, *arg1).await()
    suspend fun bzpopmin(arg0: kotlin.Long, vararg arg1: K) = async.bzpopmin(arg0, *arg1).await()
    suspend fun clientGetname() = async.clientGetname().await()
    suspend fun clientKill(arg0: kotlin.String) = async.clientKill(arg0).await()
    suspend fun clientKill(arg0: io.lettuce.core.KillArgs) = async.clientKill(arg0).await()
    suspend fun clientList() = async.clientList().await()
    suspend fun clientPause(arg0: kotlin.Long) = async.clientPause(arg0).await()
    suspend fun clientSetname(arg0: K) = async.clientSetname(arg0).await()
    suspend fun clientUnblock(arg0: kotlin.Long, arg1: io.lettuce.core.UnblockType) = async.clientUnblock(arg0, arg1).await()
    suspend fun clusterAddSlots(vararg arg0: Int) = async.clusterAddSlots(*arg0).await()
    suspend fun clusterBumpepoch() = async.clusterBumpepoch().await()
    suspend fun clusterCountFailureReports(arg0: kotlin.String) = async.clusterCountFailureReports(arg0).await()
    suspend fun clusterCountKeysInSlot(arg0: kotlin.Int) = async.clusterCountKeysInSlot(arg0).await()
    suspend fun clusterDelSlots(vararg arg0: Int) = async.clusterDelSlots(*arg0).await()
    suspend fun clusterFailover(arg0: kotlin.Boolean) = async.clusterFailover(arg0).await()
    suspend fun clusterFlushslots() = async.clusterFlushslots().await()
    suspend fun clusterForget(arg0: kotlin.String) = async.clusterForget(arg0).await()
    suspend fun clusterGetKeysInSlot(arg0: kotlin.Int, arg1: kotlin.Int) = async.clusterGetKeysInSlot(arg0, arg1).await()
    suspend fun clusterInfo() = async.clusterInfo().await()
    suspend fun clusterKeyslot(arg0: K) = async.clusterKeyslot(arg0).await()
    suspend fun clusterMeet(arg0: kotlin.String, arg1: kotlin.Int) = async.clusterMeet(arg0, arg1).await()
    suspend fun clusterMyId() = async.clusterMyId().await()
    suspend fun clusterNodes() = async.clusterNodes().await()
    suspend fun clusterReplicate(arg0: kotlin.String) = async.clusterReplicate(arg0).await()
    suspend fun clusterReset(arg0: kotlin.Boolean) = async.clusterReset(arg0).await()
    suspend fun clusterSaveconfig() = async.clusterSaveconfig().await()
    suspend fun clusterSetConfigEpoch(arg0: kotlin.Long) = async.clusterSetConfigEpoch(arg0).await()
    suspend fun clusterSetSlotImporting(arg0: kotlin.Int, arg1: kotlin.String) = async.clusterSetSlotImporting(arg0, arg1).await()
    suspend fun clusterSetSlotMigrating(arg0: kotlin.Int, arg1: kotlin.String) = async.clusterSetSlotMigrating(arg0, arg1).await()
    suspend fun clusterSetSlotNode(arg0: kotlin.Int, arg1: kotlin.String) = async.clusterSetSlotNode(arg0, arg1).await()
    suspend fun clusterSetSlotStable(arg0: kotlin.Int) = async.clusterSetSlotStable(arg0).await()
    suspend fun clusterSlaves(arg0: kotlin.String) = async.clusterSlaves(arg0).await()
    suspend fun clusterSlots() = async.clusterSlots().await()
    suspend fun command() = async.command().await()
    suspend fun commandCount() = async.commandCount().await()
    suspend fun commandInfo(vararg arg0: io.lettuce.core.protocol.CommandType) = async.commandInfo(*arg0).await()
    suspend fun commandInfo(vararg arg0: kotlin.String) = async.commandInfo(*arg0).await()
    suspend fun configGet(arg0: kotlin.String) = async.configGet(arg0).await()
    suspend fun configResetstat() = async.configResetstat().await()
    suspend fun configRewrite() = async.configRewrite().await()
    suspend fun configSet(arg0: kotlin.String, arg1: kotlin.String) = async.configSet(arg0, arg1).await()
    suspend fun dbsize() = async.dbsize().await()
    suspend fun debugCrashAndRecover(arg0: kotlin.Long) = async.debugCrashAndRecover(arg0).await()
    suspend fun debugHtstats(arg0: kotlin.Int) = async.debugHtstats(arg0).await()
    suspend fun debugObject(arg0: K) = async.debugObject(arg0).await()
    suspend fun debugOom() = async.debugOom()
    suspend fun debugReload() = async.debugReload().await()
    suspend fun debugRestart(arg0: kotlin.Long) = async.debugRestart(arg0).await()
    suspend fun debugSdslen(arg0: K) = async.debugSdslen(arg0).await()
    suspend fun debugSegfault() = async.debugSegfault()
    suspend fun decr(arg0: K) = async.decr(arg0).await()
    suspend fun decrby(arg0: K, arg1: kotlin.Long) = async.decrby(arg0, arg1).await()
    suspend fun del(vararg arg0: K) = async.del(*arg0).await()
    suspend fun digest(arg0: V) = async.digest(arg0)
    suspend fun discard() = async.discard().await()
    suspend fun <T> dispatch(arg0: io.lettuce.core.protocol.ProtocolKeyword, arg1: io.lettuce.core.output.CommandOutput<K, V, T>, arg2: io.lettuce.core.protocol.CommandArgs<K, V>) = async.dispatch<T>(arg0, arg1, arg2).await()
    suspend fun <T> dispatch(arg0: io.lettuce.core.protocol.ProtocolKeyword, arg1: io.lettuce.core.output.CommandOutput<K, V, T>) = async.dispatch<T>(arg0, arg1).await()
    suspend fun dump(arg0: K) = async.dump(arg0).await()
    suspend fun echo(arg0: V) = async.echo(arg0).await()
    suspend fun <T> eval(arg0: kotlin.String, arg1: io.lettuce.core.ScriptOutputType, vararg arg2: K) = async.eval<T>(arg0, arg1, *arg2).await()
    suspend fun <T> eval(arg0: kotlin.String, arg1: io.lettuce.core.ScriptOutputType, arg2: kotlin.Array<out K>, vararg arg3: V) = async.eval<T>(arg0, arg1, arg2, *arg3).await()
    suspend fun <T> evalsha(arg0: kotlin.String, arg1: io.lettuce.core.ScriptOutputType, vararg arg2: K) = async.evalsha<T>(arg0, arg1, *arg2).await()
    suspend fun <T> evalsha(arg0: kotlin.String, arg1: io.lettuce.core.ScriptOutputType, arg2: kotlin.Array<out K>, vararg arg3: V) = async.evalsha<T>(arg0, arg1, arg2, *arg3).await()
    suspend fun exec() = async.exec().await()
    suspend fun exists(vararg arg0: K) = async.exists(*arg0).await()
    suspend fun expire(arg0: K, arg1: kotlin.Long) = async.expire(arg0, arg1).await()
    suspend fun expireat(arg0: K, arg1: java.util.Date) = async.expireat(arg0, arg1).await()
    suspend fun expireat(arg0: K, arg1: kotlin.Long) = async.expireat(arg0, arg1).await()
    suspend fun flushCommands() = async.flushCommands()
    suspend fun flushall() = async.flushall().await()
    suspend fun flushallAsync() = async.flushallAsync().await()
    suspend fun flushdb() = async.flushdb().await()
    suspend fun flushdbAsync() = async.flushdbAsync().await()
    suspend fun geoadd(arg0: K, vararg arg1: kotlin.Any) = async.geoadd(arg0, *arg1).await()
    suspend fun geoadd(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: V) = async.geoadd(arg0, arg1, arg2, arg3).await()
    suspend fun geodist(arg0: K, arg1: V, arg2: V, arg3: io.lettuce.core.GeoArgs.Unit) = async.geodist(arg0, arg1, arg2, arg3).await()
    suspend fun geohash(arg0: K, vararg arg1: V) = async.geohash(arg0, *arg1).await()
    suspend fun geopos(arg0: K, vararg arg1: V) = async.geopos(arg0, *arg1).await()
    suspend fun georadius(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Double, arg4: io.lettuce.core.GeoArgs.Unit, arg5: io.lettuce.core.GeoRadiusStoreArgs<K>) = async.georadius(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun georadius(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Double, arg4: io.lettuce.core.GeoArgs.Unit, arg5: io.lettuce.core.GeoArgs) = async.georadius(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun georadius(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Double, arg4: io.lettuce.core.GeoArgs.Unit) = async.georadius(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun georadiusbymember(arg0: K, arg1: V, arg2: kotlin.Double, arg3: io.lettuce.core.GeoArgs.Unit, arg4: io.lettuce.core.GeoArgs) = async.georadiusbymember(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun georadiusbymember(arg0: K, arg1: V, arg2: kotlin.Double, arg3: io.lettuce.core.GeoArgs.Unit) = async.georadiusbymember(arg0, arg1, arg2, arg3).await()
    suspend fun georadiusbymember(arg0: K, arg1: V, arg2: kotlin.Double, arg3: io.lettuce.core.GeoArgs.Unit, arg4: io.lettuce.core.GeoRadiusStoreArgs<K>) = async.georadiusbymember(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun get(arg0: K) = async.get(arg0).await()
    suspend fun getStatefulConnection() = async.getStatefulConnection()
    suspend fun getbit(arg0: K, arg1: kotlin.Long) = async.getbit(arg0, arg1).await()
    suspend fun getrange(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.getrange(arg0, arg1, arg2).await()
    suspend fun getset(arg0: K, arg1: V) = async.getset(arg0, arg1).await()
    suspend fun hdel(arg0: K, vararg arg1: K) = async.hdel(arg0, *arg1).await()
    suspend fun hexists(arg0: K, arg1: K) = async.hexists(arg0, arg1).await()
    suspend fun hget(arg0: K, arg1: K) = async.hget(arg0, arg1).await()
    suspend fun hgetall(arg0: K) = async.hgetall(arg0).await()
    suspend fun hgetall(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, arg1: K) = async.hgetall(arg0, arg1).await()
    suspend fun hincrby(arg0: K, arg1: K, arg2: kotlin.Long) = async.hincrby(arg0, arg1, arg2).await()
    suspend fun hincrbyfloat(arg0: K, arg1: K, arg2: kotlin.Double) = async.hincrbyfloat(arg0, arg1, arg2).await()
    suspend fun hkeys(arg0: K) = async.hkeys(arg0).await()
    suspend fun hkeys(arg0: io.lettuce.core.output.KeyStreamingChannel<K>, arg1: K) = async.hkeys(arg0, arg1).await()
    suspend fun hlen(arg0: K) = async.hlen(arg0).await()
    suspend fun hmget(arg0: K, vararg arg1: K) = async.hmget(arg0, *arg1).await()
    suspend fun hmget(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, arg1: K, vararg arg2: K) = async.hmget(arg0, arg1, *arg2).await()
    suspend fun hmset(arg0: K, arg1: kotlin.collections.MutableMap<K, V>) = async.hmset(arg0, arg1).await()
    suspend fun hscan(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, arg1: K) = async.hscan(arg0, arg1).await()
    suspend fun hscan(arg0: K, arg1: io.lettuce.core.ScanCursor) = async.hscan(arg0, arg1).await()
    suspend fun hscan(arg0: K, arg1: io.lettuce.core.ScanCursor, arg2: io.lettuce.core.ScanArgs) = async.hscan(arg0, arg1, arg2).await()
    suspend fun hscan(arg0: K, arg1: io.lettuce.core.ScanArgs) = async.hscan(arg0, arg1).await()
    suspend fun hscan(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, arg1: K, arg2: io.lettuce.core.ScanArgs) = async.hscan(arg0, arg1, arg2).await()
    suspend fun hscan(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, arg1: K, arg2: io.lettuce.core.ScanCursor, arg3: io.lettuce.core.ScanArgs) = async.hscan(arg0, arg1, arg2, arg3).await()
    suspend fun hscan(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, arg1: K, arg2: io.lettuce.core.ScanCursor) = async.hscan(arg0, arg1, arg2).await()
    suspend fun hscan(arg0: K) = async.hscan(arg0).await()
    suspend fun hset(arg0: K, arg1: K, arg2: V) = async.hset(arg0, arg1, arg2).await()
    suspend fun hsetnx(arg0: K, arg1: K, arg2: V) = async.hsetnx(arg0, arg1, arg2).await()
    suspend fun hstrlen(arg0: K, arg1: K) = async.hstrlen(arg0, arg1).await()
    suspend fun hvals(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K) = async.hvals(arg0, arg1).await()
    suspend fun hvals(arg0: K) = async.hvals(arg0).await()
    suspend fun incr(arg0: K) = async.incr(arg0).await()
    suspend fun incrby(arg0: K, arg1: kotlin.Long) = async.incrby(arg0, arg1).await()
    suspend fun incrbyfloat(arg0: K, arg1: kotlin.Double) = async.incrbyfloat(arg0, arg1).await()
    suspend fun info(arg0: kotlin.String) = async.info(arg0).await()
    suspend fun info() = async.info().await()
    suspend fun isOpen() = async.isOpen()
    suspend fun keys(arg0: io.lettuce.core.output.KeyStreamingChannel<K>, arg1: K) = async.keys(arg0, arg1).await()
    suspend fun keys(arg0: K) = async.keys(arg0).await()
    suspend fun lastsave() = async.lastsave().await()
    suspend fun lindex(arg0: K, arg1: kotlin.Long) = async.lindex(arg0, arg1).await()
    suspend fun linsert(arg0: K, arg1: kotlin.Boolean, arg2: V, arg3: V) = async.linsert(arg0, arg1, arg2, arg3).await()
    suspend fun llen(arg0: K) = async.llen(arg0).await()
    suspend fun lpop(arg0: K) = async.lpop(arg0).await()
    suspend fun lpush(arg0: K, vararg arg1: V) = async.lpush(arg0, *arg1).await()
    suspend fun lpushx(arg0: K, vararg arg1: V) = async.lpushx(arg0, *arg1).await()
    suspend fun lrange(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Long, arg3: kotlin.Long) = async.lrange(arg0, arg1, arg2, arg3).await()
    suspend fun lrange(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.lrange(arg0, arg1, arg2).await()
    suspend fun lrem(arg0: K, arg1: kotlin.Long, arg2: V) = async.lrem(arg0, arg1, arg2).await()
    suspend fun lset(arg0: K, arg1: kotlin.Long, arg2: V) = async.lset(arg0, arg1, arg2).await()
    suspend fun ltrim(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.ltrim(arg0, arg1, arg2).await()
    suspend fun mget(vararg arg0: K) = async.mget(*arg0).await()
    suspend fun mget(arg0: io.lettuce.core.output.KeyValueStreamingChannel<K, V>, vararg arg1: K) = async.mget(arg0, *arg1).await()
    suspend fun migrate(arg0: kotlin.String, arg1: kotlin.Int, arg2: kotlin.Int, arg3: kotlin.Long, arg4: io.lettuce.core.MigrateArgs<K>) = async.migrate(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun migrate(arg0: kotlin.String, arg1: kotlin.Int, arg2: K, arg3: kotlin.Int, arg4: kotlin.Long) = async.migrate(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun move(arg0: K, arg1: kotlin.Int) = async.move(arg0, arg1).await()
    suspend fun mset(arg0: kotlin.collections.MutableMap<K, V>) = async.mset(arg0).await()
    suspend fun msetnx(arg0: kotlin.collections.MutableMap<K, V>) = async.msetnx(arg0).await()
    suspend fun multi() = async.multi().await()
    suspend fun objectEncoding(arg0: K) = async.objectEncoding(arg0).await()
    suspend fun objectIdletime(arg0: K) = async.objectIdletime(arg0).await()
    suspend fun objectRefcount(arg0: K) = async.objectRefcount(arg0).await()
    suspend fun persist(arg0: K) = async.persist(arg0).await()
    suspend fun pexpire(arg0: K, arg1: kotlin.Long) = async.pexpire(arg0, arg1).await()
    suspend fun pexpireat(arg0: K, arg1: kotlin.Long) = async.pexpireat(arg0, arg1).await()
    suspend fun pexpireat(arg0: K, arg1: java.util.Date) = async.pexpireat(arg0, arg1).await()
    suspend fun pfadd(arg0: K, vararg arg1: V) = async.pfadd(arg0, *arg1).await()
    suspend fun pfcount(vararg arg0: K) = async.pfcount(*arg0).await()
    suspend fun pfmerge(arg0: K, vararg arg1: K) = async.pfmerge(arg0, *arg1).await()
    suspend fun ping() = async.ping().await()
    suspend fun psetex(arg0: K, arg1: kotlin.Long, arg2: V) = async.psetex(arg0, arg1, arg2).await()
    suspend fun pttl(arg0: K) = async.pttl(arg0).await()
    suspend fun publish(arg0: K, arg1: V) = async.publish(arg0, arg1).await()
    suspend fun pubsubChannels() = async.pubsubChannels().await()
    suspend fun pubsubChannels(arg0: K) = async.pubsubChannels(arg0).await()
    suspend fun pubsubNumpat() = async.pubsubNumpat().await()
    suspend fun pubsubNumsub(vararg arg0: K) = async.pubsubNumsub(*arg0).await()
    suspend fun quit() = async.quit().await()
    suspend fun randomkey() = async.randomkey().await()
    suspend fun readOnly() = async.readOnly().await()
    suspend fun readWrite() = async.readWrite().await()
    suspend fun rename(arg0: K, arg1: K) = async.rename(arg0, arg1).await()
    suspend fun renamenx(arg0: K, arg1: K) = async.renamenx(arg0, arg1).await()
    suspend fun reset() = async.reset()
    suspend fun restore(arg0: K, arg1: kotlin.Long, arg2: kotlin.ByteArray) = async.restore(arg0, arg1, arg2).await()
    suspend fun restore(arg0: K, arg1: kotlin.ByteArray, arg2: io.lettuce.core.RestoreArgs) = async.restore(arg0, arg1, arg2).await()
    suspend fun role() = async.role().await()
    suspend fun rpop(arg0: K) = async.rpop(arg0).await()
    suspend fun rpoplpush(arg0: K, arg1: K) = async.rpoplpush(arg0, arg1).await()
    suspend fun rpush(arg0: K, vararg arg1: V) = async.rpush(arg0, *arg1).await()
    suspend fun rpushx(arg0: K, vararg arg1: V) = async.rpushx(arg0, *arg1).await()
    suspend fun sadd(arg0: K, vararg arg1: V) = async.sadd(arg0, *arg1).await()
    suspend fun save() = async.save().await()
    suspend fun scan(arg0: io.lettuce.core.output.KeyStreamingChannel<K>, arg1: io.lettuce.core.ScanCursor) = async.scan(arg0, arg1).await()
    suspend fun scan(arg0: io.lettuce.core.ScanCursor) = async.scan(arg0).await()
    suspend fun scan(arg0: io.lettuce.core.output.KeyStreamingChannel<K>) = async.scan(arg0).await()
    suspend fun scan(arg0: io.lettuce.core.ScanCursor, arg1: io.lettuce.core.ScanArgs) = async.scan(arg0, arg1).await()
    suspend fun scan(arg0: io.lettuce.core.ScanArgs) = async.scan(arg0).await()
    suspend fun scan() = async.scan().await()
    suspend fun scan(arg0: io.lettuce.core.output.KeyStreamingChannel<K>, arg1: io.lettuce.core.ScanCursor, arg2: io.lettuce.core.ScanArgs) = async.scan(arg0, arg1, arg2).await()
    suspend fun scan(arg0: io.lettuce.core.output.KeyStreamingChannel<K>, arg1: io.lettuce.core.ScanArgs) = async.scan(arg0, arg1).await()
    suspend fun scard(arg0: K) = async.scard(arg0).await()
    suspend fun scriptExists(vararg arg0: kotlin.String) = async.scriptExists(*arg0).await()
    suspend fun scriptFlush() = async.scriptFlush().await()
    suspend fun scriptKill() = async.scriptKill().await()
    suspend fun scriptLoad(arg0: V) = async.scriptLoad(arg0).await()
    suspend fun sdiff(vararg arg0: K) = async.sdiff(*arg0).await()
    suspend fun sdiff(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, vararg arg1: K) = async.sdiff(arg0, *arg1).await()
    suspend fun sdiffstore(arg0: K, vararg arg1: K) = async.sdiffstore(arg0, *arg1).await()
    suspend fun select(arg0: kotlin.Int) = async.select(arg0)
    suspend fun set(arg0: K, arg1: V) = async.set(arg0, arg1).await()
    suspend fun set(arg0: K, arg1: V, arg2: io.lettuce.core.SetArgs) = async.set(arg0, arg1, arg2).await()
    suspend fun setAutoFlushCommands(arg0: kotlin.Boolean) = async.setAutoFlushCommands(arg0)
    suspend fun setTimeout(arg0: java.time.Duration) = async.setTimeout(arg0)
    suspend fun setTimeout(arg0: kotlin.Long, arg1: java.util.concurrent.TimeUnit) = async.setTimeout(arg0, arg1)
    suspend fun setbit(arg0: K, arg1: kotlin.Long, arg2: kotlin.Int) = async.setbit(arg0, arg1, arg2).await()
    suspend fun setex(arg0: K, arg1: kotlin.Long, arg2: V) = async.setex(arg0, arg1, arg2).await()
    suspend fun setnx(arg0: K, arg1: V) = async.setnx(arg0, arg1).await()
    suspend fun setrange(arg0: K, arg1: kotlin.Long, arg2: V) = async.setrange(arg0, arg1, arg2).await()
    suspend fun shutdown(arg0: kotlin.Boolean) = async.shutdown(arg0)
    suspend fun sinter(vararg arg0: K) = async.sinter(*arg0).await()
    suspend fun sinter(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, vararg arg1: K) = async.sinter(arg0, *arg1).await()
    suspend fun sinterstore(arg0: K, vararg arg1: K) = async.sinterstore(arg0, *arg1).await()
    suspend fun sismember(arg0: K, arg1: V) = async.sismember(arg0, arg1).await()
    suspend fun slaveof(arg0: kotlin.String, arg1: kotlin.Int) = async.slaveof(arg0, arg1).await()
    suspend fun slaveofNoOne() = async.slaveofNoOne().await()
    suspend fun slowlogGet(arg0: kotlin.Int) = async.slowlogGet(arg0).await()
    suspend fun slowlogGet() = async.slowlogGet().await()
    suspend fun slowlogLen() = async.slowlogLen().await()
    suspend fun slowlogReset() = async.slowlogReset().await()
    suspend fun smembers(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K) = async.smembers(arg0, arg1).await()
    suspend fun smembers(arg0: K) = async.smembers(arg0).await()
    suspend fun smove(arg0: K, arg1: K, arg2: V) = async.smove(arg0, arg1, arg2).await()
    suspend fun sort(arg0: K, arg1: io.lettuce.core.SortArgs) = async.sort(arg0, arg1).await()
    suspend fun sort(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.SortArgs) = async.sort(arg0, arg1, arg2).await()
    suspend fun sort(arg0: K) = async.sort(arg0).await()
    suspend fun sort(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K) = async.sort(arg0, arg1).await()
    suspend fun sortStore(arg0: K, arg1: io.lettuce.core.SortArgs, arg2: K) = async.sortStore(arg0, arg1, arg2).await()
    suspend fun spop(arg0: K, arg1: kotlin.Long) = async.spop(arg0, arg1).await()
    suspend fun spop(arg0: K) = async.spop(arg0).await()
    suspend fun srandmember(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Long) = async.srandmember(arg0, arg1, arg2).await()
    suspend fun srandmember(arg0: K, arg1: kotlin.Long) = async.srandmember(arg0, arg1).await()
    suspend fun srandmember(arg0: K) = async.srandmember(arg0).await()
    suspend fun srem(arg0: K, vararg arg1: V) = async.srem(arg0, *arg1).await()
    suspend fun sscan(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K) = async.sscan(arg0, arg1).await()
    suspend fun sscan(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.ScanArgs) = async.sscan(arg0, arg1, arg2).await()
    suspend fun sscan(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.ScanCursor, arg3: io.lettuce.core.ScanArgs) = async.sscan(arg0, arg1, arg2, arg3).await()
    suspend fun sscan(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.ScanCursor) = async.sscan(arg0, arg1, arg2).await()
    suspend fun sscan(arg0: K) = async.sscan(arg0).await()
    suspend fun sscan(arg0: K, arg1: io.lettuce.core.ScanArgs) = async.sscan(arg0, arg1).await()
    suspend fun sscan(arg0: K, arg1: io.lettuce.core.ScanCursor, arg2: io.lettuce.core.ScanArgs) = async.sscan(arg0, arg1, arg2).await()
    suspend fun sscan(arg0: K, arg1: io.lettuce.core.ScanCursor) = async.sscan(arg0, arg1).await()
    suspend fun strlen(arg0: K) = async.strlen(arg0).await()
    suspend fun sunion(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, vararg arg1: K) = async.sunion(arg0, *arg1).await()
    suspend fun sunion(vararg arg0: K) = async.sunion(*arg0).await()
    suspend fun sunionstore(arg0: K, vararg arg1: K) = async.sunionstore(arg0, *arg1).await()
    suspend fun swapdb(arg0: kotlin.Int, arg1: kotlin.Int) = async.swapdb(arg0, arg1).await()
    suspend fun time() = async.time().await()
    suspend fun touch(vararg arg0: K) = async.touch(*arg0).await()
    suspend fun ttl(arg0: K) = async.ttl(arg0).await()
    suspend fun type(arg0: K) = async.type(arg0).await()
    suspend fun unlink(vararg arg0: K) = async.unlink(*arg0).await()
    suspend fun unwatch() = async.unwatch().await()
    suspend fun waitForReplication(arg0: kotlin.Int, arg1: kotlin.Long) = async.waitForReplication(arg0, arg1).await()
    suspend fun watch(vararg arg0: K) = async.watch(*arg0).await()
    suspend fun xack(arg0: K, arg1: K, vararg arg2: kotlin.String) = async.xack(arg0, arg1, *arg2).await()
    suspend fun xadd(arg0: K, arg1: io.lettuce.core.XAddArgs, vararg arg2: kotlin.Any) = async.xadd(arg0, arg1, *arg2).await()
    suspend fun xadd(arg0: K, arg1: kotlin.collections.MutableMap<K, V>) = async.xadd(arg0, arg1).await()
    suspend fun xadd(arg0: K, arg1: io.lettuce.core.XAddArgs, arg2: kotlin.collections.MutableMap<K, V>) = async.xadd(arg0, arg1, arg2).await()
    suspend fun xadd(arg0: K, vararg arg1: kotlin.Any) = async.xadd(arg0, *arg1).await()
    suspend fun xclaim(arg0: K, arg1: io.lettuce.core.Consumer<K>, arg2: io.lettuce.core.XClaimArgs, vararg arg3: kotlin.String) = async.xclaim(arg0, arg1, arg2, *arg3).await()
    suspend fun xclaim(arg0: K, arg1: io.lettuce.core.Consumer<K>, arg2: kotlin.Long, vararg arg3: kotlin.String) = async.xclaim(arg0, arg1, arg2, *arg3).await()
    suspend fun xdel(arg0: K, vararg arg1: kotlin.String) = async.xdel(arg0, *arg1).await()
    suspend fun xgroupCreate(arg0: io.lettuce.core.XReadArgs.StreamOffset<K>, arg1: K) = async.xgroupCreate(arg0, arg1).await()
    suspend fun xgroupDelconsumer(arg0: K, arg1: io.lettuce.core.Consumer<K>) = async.xgroupDelconsumer(arg0, arg1).await()
    suspend fun xgroupDestroy(arg0: K, arg1: K) = async.xgroupDestroy(arg0, arg1).await()
    suspend fun xgroupSetid(arg0: io.lettuce.core.XReadArgs.StreamOffset<K>, arg1: K) = async.xgroupSetid(arg0, arg1).await()
    suspend fun xlen(arg0: K) = async.xlen(arg0).await()
    suspend fun xpending(arg0: K, arg1: K, arg2: io.lettuce.core.Range<kotlin.String>, arg3: io.lettuce.core.Limit) = async.xpending(arg0, arg1, arg2, arg3).await()
    suspend fun xpending(arg0: K, arg1: io.lettuce.core.Consumer<K>, arg2: io.lettuce.core.Range<kotlin.String>, arg3: io.lettuce.core.Limit) = async.xpending(arg0, arg1, arg2, arg3).await()
    suspend fun xpending(arg0: K, arg1: K) = async.xpending(arg0, arg1).await()
    suspend fun xrange(arg0: K, arg1: io.lettuce.core.Range<kotlin.String>, arg2: io.lettuce.core.Limit) = async.xrange(arg0, arg1, arg2).await()
    suspend fun xrange(arg0: K, arg1: io.lettuce.core.Range<kotlin.String>) = async.xrange(arg0, arg1).await()
    suspend fun xread(arg0: io.lettuce.core.XReadArgs, vararg arg1: io.lettuce.core.XReadArgs.StreamOffset<K>) = async.xread(arg0, *arg1).await()
    suspend fun xread(vararg arg0: io.lettuce.core.XReadArgs.StreamOffset<K>) = async.xread(*arg0).await()
    suspend fun xreadgroup(arg0: io.lettuce.core.Consumer<K>, arg1: io.lettuce.core.XReadArgs, vararg arg2: io.lettuce.core.XReadArgs.StreamOffset<K>) = async.xreadgroup(arg0, arg1, *arg2).await()
    suspend fun xreadgroup(arg0: io.lettuce.core.Consumer<K>, vararg arg1: io.lettuce.core.XReadArgs.StreamOffset<K>) = async.xreadgroup(arg0, *arg1).await()
    suspend fun xrevrange(arg0: K, arg1: io.lettuce.core.Range<kotlin.String>, arg2: io.lettuce.core.Limit) = async.xrevrange(arg0, arg1, arg2).await()
    suspend fun xrevrange(arg0: K, arg1: io.lettuce.core.Range<kotlin.String>) = async.xrevrange(arg0, arg1).await()
    suspend fun xtrim(arg0: K, arg1: kotlin.Long) = async.xtrim(arg0, arg1).await()
    suspend fun xtrim(arg0: K, arg1: kotlin.Boolean, arg2: kotlin.Long) = async.xtrim(arg0, arg1, arg2).await()
    suspend fun zadd(arg0: K, arg1: io.lettuce.core.ZAddArgs, vararg arg2: kotlin.Any) = async.zadd(arg0, arg1, *arg2).await()
    suspend fun zadd(arg0: K, arg1: io.lettuce.core.ZAddArgs, arg2: kotlin.Double, arg3: V) = async.zadd(arg0, arg1, arg2, arg3).await()
    suspend fun zadd(arg0: K, arg1: io.lettuce.core.ZAddArgs, vararg arg2: io.lettuce.core.ScoredValue<V>) = async.zadd(arg0, arg1, *arg2).await()
    suspend fun zadd(arg0: K, arg1: kotlin.Double, arg2: V) = async.zadd(arg0, arg1, arg2).await()
    suspend fun zadd(arg0: K, vararg arg1: kotlin.Any) = async.zadd(arg0, *arg1).await()
    suspend fun zadd(arg0: K, vararg arg1: io.lettuce.core.ScoredValue<V>) = async.zadd(arg0, *arg1).await()
    suspend fun zaddincr(arg0: K, arg1: io.lettuce.core.ZAddArgs, arg2: kotlin.Double, arg3: V) = async.zaddincr(arg0, arg1, arg2, arg3).await()
    suspend fun zaddincr(arg0: K, arg1: kotlin.Double, arg2: V) = async.zaddincr(arg0, arg1, arg2).await()
    suspend fun zcard(arg0: K) = async.zcard(arg0).await()
    suspend fun zcount(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zcount(arg0, arg1, arg2).await()
    suspend fun zcount(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>) = async.zcount(arg0, arg1).await()
    suspend fun zcount(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double) = async.zcount(arg0, arg1, arg2).await()
    suspend fun zincrby(arg0: K, arg1: kotlin.Double, arg2: V) = async.zincrby(arg0, arg1, arg2).await()
    suspend fun zinterstore(arg0: K, arg1: io.lettuce.core.ZStoreArgs, vararg arg2: K) = async.zinterstore(arg0, arg1, *arg2).await()
    suspend fun zinterstore(arg0: K, vararg arg1: K) = async.zinterstore(arg0, *arg1).await()
    suspend fun zlexcount(arg0: K, arg1: io.lettuce.core.Range<out V>) = async.zlexcount(arg0, arg1).await()
    suspend fun zlexcount(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zlexcount(arg0, arg1, arg2).await()
    suspend fun zpopmax(arg0: K, arg1: kotlin.Long) = async.zpopmax(arg0, arg1).await()
    suspend fun zpopmax(arg0: K) = async.zpopmax(arg0).await()
    suspend fun zpopmin(arg0: K, arg1: kotlin.Long) = async.zpopmin(arg0, arg1).await()
    suspend fun zpopmin(arg0: K) = async.zpopmin(arg0).await()
    suspend fun zrange(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Long, arg3: kotlin.Long) = async.zrange(arg0, arg1, arg2, arg3).await()
    suspend fun zrange(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.zrange(arg0, arg1, arg2).await()
    suspend fun zrangeWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.Long, arg3: kotlin.Long) = async.zrangeWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrangeWithScores(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.zrangeWithScores(arg0, arg1, arg2).await()
    suspend fun zrangebylex(arg0: K, arg1: io.lettuce.core.Range<out V>, arg2: io.lettuce.core.Limit) = async.zrangebylex(arg0, arg1, arg2).await()
    suspend fun zrangebylex(arg0: K, arg1: kotlin.String, arg2: kotlin.String, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrangebylex(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrangebylex(arg0: K, arg1: io.lettuce.core.Range<out V>) = async.zrangebylex(arg0, arg1).await()
    suspend fun zrangebylex(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zrangebylex(arg0, arg1, arg2).await()
    suspend fun zrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String) = async.zrangebyscore(arg0, arg1, arg2, arg3).await()
    suspend fun zrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>) = async.zrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double) = async.zrangebyscore(arg0, arg1, arg2, arg3).await()
    suspend fun zrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrangebyscore(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrangebyscore(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>, arg3: io.lettuce.core.Limit) = async.zrangebyscore(arg0, arg1, arg2, arg3).await()
    suspend fun zrangebyscore(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double) = async.zrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrangebyscore(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrangebyscore(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>) = async.zrangebyscore(arg0, arg1).await()
    suspend fun zrangebyscore(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>, arg2: io.lettuce.core.Limit) = async.zrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrangebyscore(arg0: K, arg1: kotlin.String, arg2: kotlin.String, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrangebyscore(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrangebyscore(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrangebyscore(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>) = async.zrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>, arg3: io.lettuce.core.Limit) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrangebyscoreWithScores(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double) = async.zrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrangebyscoreWithScores(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrangebyscoreWithScores(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>) = async.zrangebyscoreWithScores(arg0, arg1).await()
    suspend fun zrangebyscoreWithScores(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>, arg2: io.lettuce.core.Limit) = async.zrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrangebyscoreWithScores(arg0: K, arg1: kotlin.String, arg2: kotlin.String, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrangebyscoreWithScores(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrank(arg0: K, arg1: V) = async.zrank(arg0, arg1).await()
    suspend fun zrem(arg0: K, vararg arg1: V) = async.zrem(arg0, *arg1).await()
    suspend fun zremrangebylex(arg0: K, arg1: io.lettuce.core.Range<out V>) = async.zremrangebylex(arg0, arg1).await()
    suspend fun zremrangebylex(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zremrangebylex(arg0, arg1, arg2).await()
    suspend fun zremrangebyrank(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.zremrangebyrank(arg0, arg1, arg2).await()
    suspend fun zremrangebyscore(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>) = async.zremrangebyscore(arg0, arg1).await()
    suspend fun zremrangebyscore(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zremrangebyscore(arg0, arg1, arg2).await()
    suspend fun zremrangebyscore(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double) = async.zremrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrevrange(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Long, arg3: kotlin.Long) = async.zrevrange(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrange(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.zrevrange(arg0, arg1, arg2).await()
    suspend fun zrevrangeWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.Long, arg3: kotlin.Long) = async.zrevrangeWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangeWithScores(arg0: K, arg1: kotlin.Long, arg2: kotlin.Long) = async.zrevrangeWithScores(arg0, arg1, arg2).await()
    suspend fun zrevrangebylex(arg0: K, arg1: io.lettuce.core.Range<out V>, arg2: io.lettuce.core.Limit) = async.zrevrangebylex(arg0, arg1, arg2).await()
    suspend fun zrevrangebylex(arg0: K, arg1: io.lettuce.core.Range<out V>) = async.zrevrangebylex(arg0, arg1).await()
    suspend fun zrevrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>) = async.zrevrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String) = async.zrevrangebyscore(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double) = async.zrevrangebyscore(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrevrangebyscore(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrevrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrevrangebyscore(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrevrangebyscore(arg0: io.lettuce.core.output.ValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>, arg3: io.lettuce.core.Limit) = async.zrevrangebyscore(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangebyscore(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double) = async.zrevrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscore(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zrevrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscore(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>) = async.zrevrangebyscore(arg0, arg1).await()
    suspend fun zrevrangebyscore(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>, arg2: io.lettuce.core.Limit) = async.zrevrangebyscore(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscore(arg0: K, arg1: kotlin.String, arg2: kotlin.String, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrevrangebyscore(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrevrangebyscore(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrevrangebyscore(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrevrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.Double, arg3: kotlin.Double, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrevrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: kotlin.String, arg3: kotlin.String, arg4: kotlin.Long, arg5: kotlin.Long) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4, arg5).await()
    suspend fun zrevrangebyscoreWithScores(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.Range<out kotlin.Number>, arg3: io.lettuce.core.Limit) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3).await()
    suspend fun zrevrangebyscoreWithScores(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscoreWithScores(arg0: K, arg1: kotlin.String, arg2: kotlin.String) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscoreWithScores(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>) = async.zrevrangebyscoreWithScores(arg0, arg1).await()
    suspend fun zrevrangebyscoreWithScores(arg0: K, arg1: io.lettuce.core.Range<out kotlin.Number>, arg2: io.lettuce.core.Limit) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2).await()
    suspend fun zrevrangebyscoreWithScores(arg0: K, arg1: kotlin.String, arg2: kotlin.String, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrevrangebyscoreWithScores(arg0: K, arg1: kotlin.Double, arg2: kotlin.Double, arg3: kotlin.Long, arg4: kotlin.Long) = async.zrevrangebyscoreWithScores(arg0, arg1, arg2, arg3, arg4).await()
    suspend fun zrevrank(arg0: K, arg1: V) = async.zrevrank(arg0, arg1).await()
    suspend fun zscan(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K) = async.zscan(arg0, arg1).await()
    suspend fun zscan(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.ScanArgs) = async.zscan(arg0, arg1, arg2).await()
    suspend fun zscan(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.ScanCursor, arg3: io.lettuce.core.ScanArgs) = async.zscan(arg0, arg1, arg2, arg3).await()
    suspend fun zscan(arg0: io.lettuce.core.output.ScoredValueStreamingChannel<V>, arg1: K, arg2: io.lettuce.core.ScanCursor) = async.zscan(arg0, arg1, arg2).await()
    suspend fun zscan(arg0: K) = async.zscan(arg0).await()
    suspend fun zscan(arg0: K, arg1: io.lettuce.core.ScanArgs) = async.zscan(arg0, arg1).await()
    suspend fun zscan(arg0: K, arg1: io.lettuce.core.ScanCursor, arg2: io.lettuce.core.ScanArgs) = async.zscan(arg0, arg1, arg2).await()
    suspend fun zscan(arg0: K, arg1: io.lettuce.core.ScanCursor) = async.zscan(arg0, arg1).await()
    suspend fun zscore(arg0: K, arg1: V) = async.zscore(arg0, arg1).await()
    suspend fun zunionstore(arg0: K, vararg arg1: K) = async.zunionstore(arg0, *arg1).await()
    suspend fun zunionstore(arg0: K, arg1: io.lettuce.core.ZStoreArgs, vararg arg2: K) = async.zunionstore(arg0, arg1, *arg2).await()
}

suspend fun <V> CompletionStage<V>.await(): V = suspendCoroutine { c ->
    this.thenAcceptAsync {
        c.resume(it)
    }.exceptionally(object : java.util.function.Function<Throwable, Void?> {
        override fun apply(t: Throwable): Void? {
            c.resumeWithException(t)
            return null
        }
    })
}

